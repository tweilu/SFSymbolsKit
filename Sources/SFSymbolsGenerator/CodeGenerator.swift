//
//  CodeGenerator.swift
//  SFSymbolsGenerator
//
//  Created by Tiffany Lu on 12/13/22.
//

import Foundation

public final class CodeGenerator {

    private static let plistDecoder = PropertyListDecoder()
    private static let specialCases = [
        "repeat", "case", "return"
    ]
    private static let codegenDisclaimer = "// Do not modify. Automatically generated by SFSymbolsGenerator.\n"

    public func run() throws {

        let versions = try generateVersions()

        _ = try generateSymbols(nameAvailability: versions)
        _ = try generateCategories()
        _ = try generateSymbolsSearchTerms()
        _ = try generateSymbolCaseIterable()

    }

    /// Format a raw SFSymbol value as its enum case.
    private func formatRawValue(_ rawValue: String) -> String {
        var value = rawValue
        if value.startsWithNumber() {
            value.insert("_", at: value.startIndex)
        }
        let components = value.split(separator: ".")
        let first = components.first!
        let remainingComponents = components.dropFirst(1)
        let result = first.appending(remainingComponents.map({ $0.capitalized }).joined())
        if Self.specialCases.contains(result) {
            return "`\(result)`"
        }
        return result
    }

    private func getCodegenPath() -> URL {
        var url = URL(fileURLWithPath: FileManager.default.currentDirectoryPath)
        url.appendPathComponent("Sources", isDirectory: true)
        url.appendPathComponent("SFSymbolsKit", isDirectory: true)
        url.appendPathComponent("codegen", isDirectory: true)
        return url
    }

    private func generateSymbols(nameAvailability: NameAvailability) throws -> Bool {

        let url = Bundle.module.url(forResource: "symbol_order", withExtension: "plist")!
        let data = try Data(contentsOf: url)
        let symbols = try Self.plistDecoder.decode([String].self, from: data)

        var symbolsString = "\(Self.codegenDisclaimer)\nenum SFSymbol: String, Codable {\n"
        symbolsString.append(contentsOf: symbols.map({
            var availabilityString: String? = nil
            if let yearString = nameAvailability.symbols[$0] {
                availabilityString = nameAvailability.yearToAvailableStringMap[yearString]
            }
            return generateSymbolCase($0, availability: availabilityString)
        }).joined(separator: "\n"))
        symbolsString.append(contentsOf: "\n}")

        let filename = getCodegenPath().appendingPathComponent("SFSymbol.swift", isDirectory: false)
        do {
            try symbolsString.write(to: filename, atomically: true, encoding: String.Encoding.utf8)
            return true
        } catch {
            // failed to write file – bad permissions, bad filename, missing permissions, or more likely it can't be converted to the encoding
            print("Failed to generate SFSymbols.swift: \(error)")
        }
        return false
    }

    private func generateSymbolCase(_ rawValue: String, availability: String?) -> String {
        var result = ""
        if let availability = availability {
            result.append(contentsOf: "\(availability)\n")
        }
        result.append(contentsOf: "    case \(formatRawValue(rawValue)) = \"\(rawValue)\"")
        return result
    }

    // MARK: - Version availability helpers

    private func generateVersions() throws -> NameAvailability {
        let url = Bundle.module.url(forResource: "name_availability", withExtension: "plist")!
        let data = try Data(contentsOf: url)
        let nameAvailability = try Self.plistDecoder.decode(NameAvailabilityPlist.self, from: data)

        var yearToAvailableStringMap = [String: String]()
        for (version, versions) in nameAvailability.yearToRelease {
            var keyedVersions = [PlatformKey: String]()
            for (rawPlatform, value) in versions {
                if let platform = PlatformKey(rawValue: rawPlatform) {
                    keyedVersions[platform] = value
                }
            }
            yearToAvailableStringMap[version] = generateIfAvailable(versionMap: keyedVersions)
        }
        return NameAvailability(symbols: nameAvailability.symbols,
                                yearToAvailableStringMap: yearToAvailableStringMap)
    }

    private func generateIfAvailable(versionMap: [PlatformKey: String]) -> String {
        let result = versionMap.reduce(into: [String]()) { (partialResult, arg1) in
            let (platform, version) = arg1
            partialResult.append("\(platform.rawValue) \(version)")
        }
        return "    @available(\(result.joined(separator: ", ")), *)"
    }

    // MARK: - SFSymbol+CaseIterable

    private func generateSymbolCaseIterable() throws -> Bool {

        let url = Bundle.module.url(forResource: "symbol_order", withExtension: "plist")!
        let data = try Data(contentsOf: url)
        let symbols = try Self.plistDecoder.decode([String].self, from: data)

        var string = """
        \(Self.codegenDisclaimer)
        extension SFSymbol: CaseIterable {
            static var allCases: [SFSymbol] {
                allCasesRaw.compactMap {
                    SFSymbol(rawValue: $0)
                }
            }

            static var allCasesRaw: [String] = [

        """

        string.append(contentsOf: symbols.map({ "\"\($0)\"" }).joined(separator: ", "))

        string.append(contentsOf: "\n    ]\n")
        string.append(contentsOf: "\n}\n")

        let filename = getCodegenPath().appendingPathComponent("SFSymbol+CaseIterable.swift", isDirectory: false)
        do {
            try string.write(to: filename, atomically: true, encoding: String.Encoding.utf8)
            return true
        } catch {
            // failed to write file – bad permissions, bad filename, missing permissions, or more likely it can't be converted to the encoding
            print("Failed to generate SFSymbols+CaseIterable.swift: \(error)")
        }
        return false

    }

    // MARK: - Search Terms

    private func generateSymbolsSearchTerms() throws -> Bool {

        let url = Bundle.module.url(forResource: "symbol_search", withExtension: "plist")!
        let data = try Data(contentsOf: url)
        let symbolSearchMap = try Self.plistDecoder.decode([String: [String]].self, from: data)

        var string = """
        \(Self.codegenDisclaimer)
        extension SFSymbol {
            var searchTerms: [String] {
                switch self {

        """

        for (key, value) in symbolSearchMap {
            string.append(contentsOf: searchTerms(symbol: key, searchTerms: value))
        }
        let trailing = """
                    default: return []
                }
            }
        }
        """
        string.append(contentsOf: trailing)


        let filename = getCodegenPath().appendingPathComponent("SFSymbol+Search.swift", isDirectory: false)
        do {
            try string.write(to: filename, atomically: true, encoding: String.Encoding.utf8)
            return true
        } catch {
            // failed to write file – bad permissions, bad filename, missing permissions, or more likely it can't be converted to the encoding
            print("Failed to generate SFSymbols+Search.swift: \(error)")
        }
        return false
    }

    private func searchTerms(symbol: String, searchTerms: [String]) -> String {
        let all = searchTerms + [symbol]
        return "            case .\(formatRawValue(symbol)): return \(all)\n"
    }

    // MARK: - Categories

    private func generateCategories() throws -> Bool {

        var url = Bundle.module.url(forResource: "categories", withExtension: "plist")!
        var data = try Data(contentsOf: url)
        let categories = try Self.plistDecoder.decode([[String: String]].self, from: data)

        url = Bundle.module.url(forResource: "symbol_categories", withExtension: "plist")!
        data = try Data(contentsOf: url)
        let symbolCategories = try Self.plistDecoder.decode([String: [String]].self, from: data)

        var categorySymbolMap = [String: [String]]()
        for (key, categories) in symbolCategories {
            for category in categories {
                if categorySymbolMap[category] == nil {
                    categorySymbolMap[category] = []
                }
                categorySymbolMap[category]?.append(key)
            }
        }

        var fullCategories = [Category]()
        for category in categories {
            let name = category["key"]!
            fullCategories.append(Category(name: name, icon: category["icon"]!, symbols: categorySymbolMap[name] ?? []))
        }

        let structString = """
            \(Self.codegenDisclaimer)
            struct SFSymbolCategory: Codable, Hashable {
                let name: String
                let icon: SFSymbol
                let symbols: [SFSymbol]
                init(name: String, icon: String, symbols: [String]) {
                    self.name = name
                    let availableSymbols = symbols.compactMap { SFSymbol(rawValue: $0) }
                    self.symbols = availableSymbols
                    if let icon = SFSymbol(rawValue: icon) {
                        self.icon = icon
                    } else {
                        self.icon = availableSymbols.first!
                    }
                }
            }
            
            """
        var categoriesString = structString

        categoriesString.append(contentsOf: "extension SFSymbolCategory {\n")
        categoriesString.append(contentsOf: fullCategories.map({ categoryCodeGen($0) }).joined(separator: "\n"))
        categoriesString.append(contentsOf: "\n    static let allCases: [SFSymbolCategory] = [\(fullCategories.map({ ".\($0.name)" }).joined(separator: ", "))]")
        categoriesString.append(contentsOf: "\n}")

        let filename = getCodegenPath().appendingPathComponent("SFSymbolCategory.swift", isDirectory: false)
        do {
            try categoriesString.write(to: filename, atomically: true, encoding: String.Encoding.utf8)
            return true
        } catch {
            print("Failed to generate SFSymbolCategory.swift: \(error)")
        }

        return true
    }

    private func categoryCodeGen(_ category: Category) -> String {
        let symbols = category.symbols.map({ "\"\($0)\"" }).joined(separator: ", ")
        return "    static let \(category.name) = SFSymbolCategory(name: \"\(category.name)\", icon: \"\(category.icon)\", symbols: [\(symbols)])"
    }

}

extension String {
    func startsWithNumber() -> Bool {
        if count > 0 {
            return self[startIndex].isNumber
        }
        return false
    }
}

struct Category {
    let name: String
    let icon: String
    let symbols: [String]
}

enum PlatformKey: String, Codable {
    case macOS, tvOS, iOS, watchOS
}
struct NameAvailability {
    let symbols: [String: String]
    let yearToAvailableStringMap: [String: String]
}
struct NameAvailabilityPlist: Codable {
    let symbols: [String: String]
    let yearToRelease: [String: [String: String]]
    enum CodingKeys: String, CodingKey {
        case symbols
        case yearToRelease = "year_to_release"
    }
}
